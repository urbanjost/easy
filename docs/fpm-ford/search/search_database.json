var tipuesearch = {"pages":[{"title":" easy ","text":"easy CONCEPT UNDER DEVELOPMENT CONCEPT UNDER DEVELOPMENT CONCEPT UNDER DEVELOPMENT CHANGELOG and BUILD ACTION STATUS Name easy -  an example github fpm repository Topics using easy to start a new fpm(1) github repository basic fpm usage basic git usage github actions to verify repository changes using ford(1) for documentation Adding plug-ins fpm-man fpm-search github topics registering your project in the fpm(1) registry resources references Description You might be starting off small, but you think your next Fortran project\ncould really grow into something big. Well, it can be hard enough just writing your Fortran code. But you have this nagging feeling you \n+ should be using version control\n+ will want collaborators to be able to work with you on the project\n+ should be generating developer documentation as well as user documention\n  for the code\n+ want to easily share your results\n+ and everyone says you should be building in unit testing of your code\n  as you develop it You want the test runs and builds and document generation to run\nautomatically, of course. And then there are all those compilers switches , and your code will\nlikely require a build tool as it grows in complexity, and you would\nlike to easily incorporate existing code into yours so you are not\nspending precious time reinventing the wheel. It can be hard to get started on the right foot. You’ve maybe heard of github and gitlab and git(1), svn(1) and hg(1), rumblings\nabout Jenkins and github actions and TOML and YAML configuration files and\nmarkdown, LaTex, and HTML. fpm(1) and Cmake and make(1) and doxygen(1)\nand ford(1) have probably come up too. And this all has to work with\nthe NAG and Intel and NVidia and GNU compilers just to start with; and\nmaybe Cray/HPE and IBM sooner than later, and so on. Sheesh. You just\nwant to write some Fortran code, right? So lets try to provide the minimal guide to get started that out of the\nbox has you in a position to satisfy all those requirements. Getting started We’re going to make some selections for you, but for now we’ll assume you\nare starting out with nothing but git(1) and a Fortran compiler and a CLI\n(Command Line Interface, typically a terminal emulator running a shell). We are also assuming your project is standard Fortran and does not\ndepend upon external libraries yet, although how to add external system\nlibraries and other fpm packages via your fpm.toml file is described in\nthe manifest file guide on the fpm(1) site (one of those decisions we are\nmaking for you is going to be to use git and github and fpm ,\nthe Fortran Package Manager). create a new github repository from this template You will need a github.com account . That is pretty easy.\nGo to the github site and create an account. Now go to this site (https://github.com/urbanjost/easy)\nand click on “use this template” and create a new repository on your\ngithub site. When you pick the new name for your repository at the prompt it is best to\nkeep it a lowercase name that can also be a Fortran variable name. That\nis, use a-z, 0-9, and underscores (or dashes if you must) and start\nit with a letter. We will assume you changed the directory name to\n“project1”, and that your github repository name is “johndoe” . Use\nthe actual names you selected in the following examples . Except for perhaps selecting a new license file just stick to the\nbasics at this juncture unless you have done this before. But on your new site, go to “settings” and under “Github Pages” select\nthe “main” branch, and the “doc” directory and click on “save” . You are done with the initial setup. You have already completed more of the\nstated goals than you imagine. Lets move off the web site and back to your\nplatform. Now, in your CLI go to the directory where you want to create your\nFortran projects and make a directory called “github” and enter it to run git clone https://github.com/johndoe/project1.git Enter the “project1” directory and edit the file “fpm.toml” and change\nthe metadata at the top to reflect your name and project. The critical\nline to change is the ‘name=”easy”’ line; where you should change “easy”\nto your chosen project name (ie. “project1” in this example). Now edit the CHANGELOG.md file and replace “YOUR_*” names\nwith your github repository name and your project name and so on. The\nstrings to change are YOUR_PROJECT_NAME, YOUR_FIRSTNAME, YOUR_LASTNAME,\nYOUR_SITE_NAME, YOUR_REPOSITORY_NAME. Do the same with the STATUS.md file as well. Even without a compiler or fpm available you can now start changing the\nsample code, and then optionally push the changes back to the repository where they\nwill be compiled with several compilers and be tested with the “fpm test”\ncommand automatically. In addition, developer documentation will be generated using ford . Lets give that a go before we move on in the CLI.  Lets assume you change\nthe file in app/main.f90. Adding a “print *, ‘my first change’ is sufficient.  Then you enter the following from within your project\ndirectory: # show the files you have changed git status # show the changes in detail git diff # add the changed files to the list of files to commit to your new version git commit --all # adds all the files you changed # ALTERNATIVELY, individually add the file(s) you changed # optionally you can list the files by name with add command(s) git add fpm.toml app/main.f90 CHANGELOG.md # create your new version ( just \"git commit\" will take you into an editor # where you can create a more complete description of your changes). git commit -m 'test using my repository' # push the changes back to your github repository git push If you go to your github repository site you will see the results of\nthe tests in the STATUS.md file. You can also use the “Actions” button at the top. Hopefully, everything was compiled on several platforms\nand the “fpm test” command was run on each platform. Building with fpm(1) Well, that shows a lot of things are in place already, but you do not\nwant to have to push every change to your web site, so you need to\njust do that when you are ready with a new version. Back at the CLI\nyou would just enter fpm test But first , if gfortran is not your default compiler you want to\nset the environment variable FPM_COMPILER. In bash(1) shells you might\nenter something like export FPM_COMPILER = ifort Now you will not have to keep adding “–compiler ifort” to all the fpm commands that need to know which compiler to use (run, test, build,\ninstall, …). The value you have to set is probably just your compiler\nname. So assuming your github repository is public others can now use your\ncode as an fpm dependency by using it in their fpm.toml file using\nsomething like [dependencies] M_time = { git = \"https://github.com/$YOUR_REPRO/project1.git\" } and at your discretion others can now collaborate with you on its\ndevelopment via the WWW (or an internal github server in a very\nsimiliar manner). Developer documentation if being built via ford in the repository directory docs/fpm-ford, and your tests are being\nrun on Ubuntu, MSWindows, and MacOS systems with gfortran, and ifort on\nUbuntu automatically. Hopefully, this is starting to feel like progress. Developer Documentation ford ford(1) output . See Also Fortran Package Manager ) Discussion is welcome here as well as at\n - Fortran Discourse is a resource for discussion\n   Fortran \n - Google Fortran newsgroup is\n   another popular Fortran forum\n - The Fortran Wiki contains information on many Fortran resources\n - Fortran compiler sites have Fortran reference manuals available\n - Fortran Package Manager has a growing list of\n   resources including how to setup Fortran compilers, fpm(1) Fortran compilers Fortran references git fpm Your first time: get github account; install git, set up ssh.\nTypical use: add, commit, push, status, and diff.\nStart a new repository: from scratch, or with an existing project. Version control is the only reasonable way to keep track of changes in code, manuscripts, presentations, and data analysis projects. Your first time with git and github If you’ve never used git or github before, there are a bunch of things\nthat you need to do. It’s very well explained on github, but repeated\nhere for completeness. Get a github account . Download and install git . Set up git with your user name and email . Open a terminal / shell and type : $ git config -- global user . name \"Your name here\" $ git config -- global user . email \"your_email@example.com\" ( Don ’ t type the $ ; that just indicates that you ’ re doing this at the command line . ) I also do : $ git config -- global color . ui true $ git config -- global core . editor emacs The first of these will enable colored output in the terminal ; the second tells git that you want to use emacs . Set up ssh on your computer . I like Roger Peng ’ s guide to setting up password - less logins . Also see github ’ s guide to generating SSH keys . Look to see if you have files ~/. ssh / id_rsa and ~/. ssh / id_rsa . pub . If not , create such public / private keys : Open a terminal / shell and type : $ ssh - keygen - t rsa - C \"your_email@example.com\" Copy your public key ( the contents of the newly - created id_rsa . pub file ) into your clipboard . On a Mac , in the terminal / shell , type : $ pbcopy < ~/. ssh / id_rsa . pub Paste your ssh public key into your github account settings . Go to your github Account Settings Click “ SSH Keys ” on the left . Click “ Add SSH Key ” on the right . Add a label ( like “ My laptop ” ) and paste the public key into the big text box . In a terminal / shell , type the following to test it : $ ssh - T git @ github . com If it says something like the following , it worked : Hi username ! You 've successfully authenticated, but Github does not provide shell access . git/github As you collaborate with others and start releasing official versions you will use more and more\ngit commands, but initially you can with by with adding, committing, and pushing your changes.\nLet’s make you master a few concepts as covered in this git/github tutorial . markdown github pages and using HTML and HTML in markdown Automating your call to fpm test Automating your page deployment  https://github.com/JamesIves/github-pages-deploy-action github topics Any project complete enough should generate a github Release and add the topic “fortran-package-manager”\nto their github repository. Putting out a release lets users know you have reached a milestone where something is fully useable.\nIt is very easy to overlook making a release, but a lot of consumers of github packages consider it a red flag\nif no release is present. Topic names that are well chosen make it much easier to find your project. In particular, fpm(1) projects want\nto include the topic fortran-package-manager . Then, if\nyou click on the topic you will see a burgeoning list of other fpm(1)-compatible packages. Fortran References fpm resources fpm(Fortran Package Manager) fpm manifest file or your fpm.toml file git resources github resources github.com github actions [github markdown] Fortran reference materials Fortran 2018 Standard GNU gfortran intrinsic descriptions J3 compiler information GNU gcc **automatic documentation tools ford doxygen Fortran resources Fortran Wiki contains information on many Fortran resources Fortran Discourse Google Fortran newsgroup Fortran-lang Fortran Standard Library project Developer Info John Doe","tags":"home","url":"index.html"},{"title":"say_hello – easy","text":"public  subroutine say_hello() Arguments None Source Code subroutine say_hello print * , \"Hello, easy!\" end subroutine say_hello","tags":"","url":"proc/say_hello.html"},{"title":"mysin – easy","text":"public pure elemental function mysin(r) result(answer) Arguments Type Intent Optional Attributes Name real, intent(in) :: r MYSIN(3f) is a trivial function for demonstration purposes. Return Value real Source Code elemental pure function mysin ( r ) result ( answer ) !> MYSIN(3f) is a trivial function for demonstration purposes. !  It calls the intrinsic SIN real , intent ( in ) :: r real :: answer answer = sin ( r ) end function mysin","tags":"","url":"proc/mysin.html"},{"title":"mysqrt – easy","text":"public pure elemental function mysqrt(r) result(answer) Arguments Type Intent Optional Attributes Name real, intent(in) :: r MYSQRT(3f) is a trivial function for demonstration purposes. Return Value real Source Code elemental pure function mysqrt ( r ) result ( answer ) !> MYSQRT(3f) is a trivial function for demonstration purposes. !  It calls the intrinsic SQRT real , intent ( in ) :: r real :: answer answer = sqrt ( r ) end function mysqrt","tags":"","url":"proc/mysqrt.html"},{"title":"easy – easy","text":"Subroutines public  subroutine say_hello () Arguments None","tags":"","url":"module/easy.html"},{"title":"easy__sample – easy","text":"Functions public pure elemental function mysin (r) result(answer) Arguments Type Intent Optional Attributes Name real, intent(in) :: r MYSIN(3f) is a trivial function for demonstration purposes. Return Value real public pure elemental function mysqrt (r) result(answer) Arguments Type Intent Optional Attributes Name real, intent(in) :: r MYSQRT(3f) is a trivial function for demonstration purposes. Return Value real","tags":"","url":"module/easy__sample.html"},{"title":"main – easy","text":"Source Code program main implicit none print * , \"hello from project easy\" end program main","tags":"","url":"program/main.html"},{"title":"check – easy","text":"Uses easy__sample Variables Type Attributes Name Initial real, parameter :: PI = atan(1.0)*4.0 Source Code program check use easy__sample , only : mysqrt , mysin implicit none real , parameter :: PI = atan ( 1.0 ) * 4.0 print * , \"Put some tests in here!\" print * , epsilon ( 0.0 ) print * , mysqrt ( 10 0.0 ) print * , PI ! comparing reals print * , mysin ( PI ). eq . 0.0 , mysin ( PI ), 0.0 print * , mysin ( PI / 2.0 ). eq . 1.0 , mysin ( PI / 2.0 ), 1.0 print * , mysin ( PI / 4.0 ) ** 2. eq . 0.5 , mysin ( PI / 4.0 ) ** 2 , 0.5 print * , mysin ( 0.0 ). eq . 0 , mysin ( 0.0 ), 0 end program check","tags":"","url":"program/check.html"},{"title":"easy.f90 – easy","text":"Source Code module easy implicit none private public :: say_hello contains subroutine say_hello print * , \"Hello, easy!\" end subroutine say_hello end module easy","tags":"","url":"sourcefile/easy.f90.html"},{"title":"main.f90 – easy","text":"Source Code program main implicit none print * , \"hello from project easy\" end program main","tags":"","url":"sourcefile/main.f90.html"},{"title":"check.f90 – easy","text":"Source Code program check use easy__sample , only : mysqrt , mysin implicit none real , parameter :: PI = atan ( 1.0 ) * 4.0 print * , \"Put some tests in here!\" print * , epsilon ( 0.0 ) print * , mysqrt ( 10 0.0 ) print * , PI ! comparing reals print * , mysin ( PI ). eq . 0.0 , mysin ( PI ), 0.0 print * , mysin ( PI / 2.0 ). eq . 1.0 , mysin ( PI / 2.0 ), 1.0 print * , mysin ( PI / 4.0 ) ** 2. eq . 0.5 , mysin ( PI / 4.0 ) ** 2 , 0.5 print * , mysin ( 0.0 ). eq . 0 , mysin ( 0.0 ), 0 end program check","tags":"","url":"sourcefile/check.f90.html"},{"title":"easy__sample.f90 – easy","text":"Source Code module easy__sample implicit none private public :: mysqrt public :: mysin contains elemental pure function mysqrt ( r ) result ( answer ) !> MYSQRT(3f) is a trivial function for demonstration purposes. !  It calls the intrinsic SQRT real , intent ( in ) :: r real :: answer answer = sqrt ( r ) end function mysqrt elemental pure function mysin ( r ) result ( answer ) !> MYSIN(3f) is a trivial function for demonstration purposes. !  It calls the intrinsic SIN real , intent ( in ) :: r real :: answer answer = sin ( r ) end function mysin end module easy__sample","tags":"","url":"sourcefile/easy__sample.f90.html"}]}